name: Run Smoke Tests (Diag)

on:
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

env:
  # Required
  BASE: ${{ secrets.FUNC_BASE_URL }}          # e.g. https://<something>.azurewebsites.net
  CODE: ${{ secrets.FUNC_CODE_DEFAULT }}      # default Function key (no ?code=)

  # Optional helpers (use if discovery fails)
  APP_OVR: ${{ secrets.FUNC_APP_NAME }}       # exact Function App name as shown in Azure portal
  RG_OVR:  ${{ secrets.AZURE_RESOURCE_GROUP }}# resource group name (optional)

jobs:
  smoke:
    runs-on: ubuntu-latest

    steps:
      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Install tools
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Detect Function App and function URLs
        id: detect
        shell: bash
        env:
          BASE: ${{ env.BASE }}
          CODE: ${{ env.CODE }}
          APP_OVR: ${{ env.APP_OVR }}
          RG_OVR:  ${{ env.RG_OVR }}
        run: |
          set -euo pipefail

          BASE="${BASE:?FUNC_BASE_URL secret is missing}"
          CODE="${CODE:?FUNC_CODE_DEFAULT secret is missing}"

          echo "BASE: $BASE"
          HOST=$(echo "$BASE" | sed -E 's#https?://([^/]+).*#\1#')
          echo "Derived HOST: $HOST"

          # 1) Resolve Function App name
          if [ -n "${APP_OVR}" ]; then
            APP="$APP_OVR"
            echo "Using APP override: $APP"
          else
            echo "Discovering app name from host…"
            APP=$(az resource list --resource-type Microsoft.Web/sites \
                  --query "[?properties.defaultHostName=='$HOST'].name | [0]" -o tsv)
            if [ -z "$APP" ]; then
              APP=$(az resource list --resource-type Microsoft.Web/sites \
                    --query "[?contains(properties.defaultHostName, '$HOST')].name | [0]" -o tsv)
            fi
            if [ -z "$APP" ]; then
              echo "::group::Debug web sites"
              az resource list --resource-type Microsoft.Web/sites -o table || true
              echo "::endgroup::"
              echo "::error::Unable to resolve Function App name from host '$HOST'. Add secret FUNC_APP_NAME."
              exit 1
            fi
          fi
          echo "Function App: $APP"

          # 2) Resolve Resource Group
          if [ -n "${RG_OVR}" ]; then
            RG="$RG_OVR"
            echo "Using RG override: $RG"
          else
            echo "Discovering resource group…"
            RG=$(az resource list --resource-type Microsoft.Web/sites \
                 --query "[?name=='$APP'].resourceGroup | [0]" -o tsv)
            if [ -z "$RG" ]; then
              RG=$(az resource list --resource-type Microsoft.Web/sites \
                   --query "[?contains(properties.defaultHostName, '$HOST') && name=='$APP'].resourceGroup | [0]" -o tsv)
            fi
            if [ -z "$RG" ]; then
              echo "::group::Debug web sites"
              az resource list --resource-type Microsoft.Web/sites -o table || true
              echo "::endgroup::"
              echo "::error::Could not discover resource group for app '$APP'. Add secret AZURE_RESOURCE_GROUP."
              exit 1
            fi
          fi
          echo "Resource Group: $RG"

          # 3) List functions
          az functionapp function list -g "$RG" -n "$APP" -o json > funcs.json
          echo "=== Deployed functions ==="
          jq -r '.[] | [.name, .invokeUrlTemplate] | @tsv' funcs.json || true

          mkurl() {
            local name="$1"
            local u
            u=$(jq -r --arg N "$name" '.[] | select(.name==$N) | .invokeUrlTemplate // empty' funcs.json)
            if [ -z "$u" ] || [ "$u" = "null" ]; then
              echo "$BASE/api/$name?code=$CODE"
            else
              if echo "$u" | grep -q 'code='; then echo "$u"; else echo "$u?code=$CODE"; fi
            fi
          }

          # Export URLs for functions that actually exist
          for N in dbx_health transfer_property_owner doorloop_writeback webhook_ingestor dropbox_upload; do
            if jq -e --arg N "$N" '.[] | select(.name==$N)' funcs.json >/dev/null; then
              echo "${N}_url=$(mkurl "$N")" >> $GITHUB_OUTPUT
            fi
          done

      - name: Show discovered URLs
        run: |
          echo "dbx_health:              ${{ steps.detect.outputs.dbx_health_url }}"
          echo "transfer_property_owner: ${{ steps.detect.outputs.transfer_property_owner_url }}"
          echo "dropbox_upload:          ${{ steps.detect.outputs.dropbox_upload_url }}"
          echo "webhook_ingestor:        ${{ steps.detect.outputs.webhook_ingestor_url }}"
          echo "doorloop_writeback:      ${{ steps.detect.outputs.doorloop_writeback_url }}"

      - name: Health check (dbx_health)
        if: ${{ steps.detect.outputs.dbx_health_url != '' }}
        run: |
          url="${{ steps.detect.outputs.dbx_health_url }}"
          echo "GET $url"
          curl -sS "$url" | jq -r .

      - name: Dry-run ownership transfer (no changes)
        if: ${{ steps.detect.outputs.transfer_property_owner_url != '' }}
        shell: bash
        run: |
          url="${{ steps.detect.outputs.transfer_property_owner_url }}"
          echo "POST $url"
          cat > body.json <<'JSON'
          {
            "from_owner": {"id": 101, "name": "Sunset Capital Partners"},
            "to_owner":   {"id": 202, "name": "Northstar Holdings"},
            "property":   {"id": 201, "name": "Sunset Villas"},
            "dry_run": true
          }
          JSON
          resp=$(curl -s -S -w "\n%{http_code}" -H "Content-Type: application/json" -d @body.json "$url")
          body=$(echo "$resp" | head -n -1); code=$(echo "$resp" | tail -n 1)
          echo "$body" | jq -r .
          test "$code" -ge 200 -a "$code" -lt 300

      - name: Upload a tiny smoke file to Dropbox
        if: ${{ steps.detect.outputs.dropbox_upload_url != '' }}
        shell: bash
        run: |
          url="${{ steps.detect.outputs.dropbox_upload_url }}"
          printf "hello from smoke %s\n" "$(date -u +%s)" > msg.txt
          b64=$(base64 -w0 msg.txt 2>/dev/null || base64 msg.txt)
          ts=$(date +%s)
          cat > body.json <<JSON
          {
            "entity_type": "LeaseSigned",
            "meta": {
              "owner_id": 101,
              "owner_name": "Sunset Capital Partners",
              "property_id": 201,
              "property_name": "Sunset Villas",
              "unit_id": 5,
              "unit_name": "unit-5b-5",
              "lease_id": 6001,
              "tenant_slug": "jane-smith"
            },
            "original_filename": "smoke-\(ts).txt",
            "file_base64": "$b64"
          }
          JSON
          echo "POST $url"
          curl -sS -H "Content-Type: application/json" -d @body.json "$url" | jq -r .
